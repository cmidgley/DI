{"version":3,"file":"index.js","sources":["../../src/transformer/constant.ts","../../src/transformer/before/util.ts","../../src/transformer/before/visitor/visit-class-like-declaration.ts","../../src/util/ts-util.ts","../../src/transformer/before/visitor/visit-call-expression.ts","../../src/transformer/before/visitor/visit-node.ts","../../src/transformer/before/before-transformer.ts","../../src/transformer/after/visitor/visit-root-block.ts","../../src/transformer/after/visitor/visit-root-block-source-file.ts","../../src/transformer/after/visitor/visit-root-block-block.ts","../../src/transformer/after/visitor/visit-define-array-literal-expression.ts","../../src/transformer/after/visitor/visit-node.ts","../../src/transformer/after/after-transformer.ts","../../src/transformer/di.ts"],"sourcesContent":["export const CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER = `___CTOR_ARGS___`;\nexport const DI_CONTAINER_NAME = \"DIContainer\";\n","import { TS } from \"../../type/type\";\nimport { VisitorContext } from \"../visitor-context\";\n\n/**\n * A TypeNode such as IFoo<string> should still yield the service name \"IFoo\".\n * This helper generates a proper service name from a TypeNode\n */\nexport function pickServiceOrImplementationName(\n  node: TS.Expression | TS.TypeNode | TS.EntityName,\n  context: VisitorContext\n): string {\n  const { typescript } = context;\n\n  if (typescript.isTypeReferenceNode(node)) {\n    return pickServiceOrImplementationName(node.typeName, context);\n  } else if (typescript.isIndexedAccessTypeNode(node)) {\n    return `${pickServiceOrImplementationName(\n      node.objectType,\n      context\n    )}[${pickServiceOrImplementationName(node.indexType, context)}]`;\n  } else {\n    return node.getFullText().trim();\n  }\n}\n","import { CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER } from \"../../constant\";\nimport { TS } from \"../../../type/type\";\nimport { BeforeVisitorOptions } from \"../before-visitor-options\";\nimport { VisitorContext } from \"../../visitor-context\";\nimport { pickServiceOrImplementationName } from \"../util\";\n\nexport function visitClassLikeDeclaration(\n  options: BeforeVisitorOptions<TS.ClassLikeDeclaration>\n): TS.VisitResult<TS.Node> {\n  const { node, childContinuation, continuation, context } = options;\n  const { typescript, factory } = context;\n  const constructorDeclaration = node.members.find(\n    typescript.isConstructorDeclaration\n  );\n\n  // If there are no constructor declaration for the ClassLikeDeclaration, there's nothing to do\n  if (constructorDeclaration == null) {\n    return childContinuation(node);\n  }\n\n  const updatedClassMembers: readonly TS.ClassElement[] = [\n    ...(node.members.map(continuation) as TS.ClassElement[]),\n    factory.createGetAccessorDeclaration(\n      undefined,\n      [\n        factory.createModifier(typescript.SyntaxKind.PublicKeyword),\n        factory.createModifier(typescript.SyntaxKind.StaticKeyword),\n      ],\n      factory.createComputedPropertyName(\n        factory.createIdentifier(\n          `Symbol.for(\"${CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER}\")`\n        )\n      ),\n      [],\n      undefined,\n      factory.createBlock([\n        factory.createReturnStatement(\n          getParameterTypeNamesAsArrayLiteral(\n            constructorDeclaration.parameters,\n            context\n          )\n        ),\n      ])\n    ),\n  ];\n\n  if (typescript.isClassDeclaration(node)) {\n    return factory.updateClassDeclaration(\n      node,\n      node.decorators,\n      node.modifiers,\n      node.name,\n      node.typeParameters,\n      node.heritageClauses,\n      updatedClassMembers\n    );\n  } else {\n    return factory.updateClassExpression(\n      node,\n      node.decorators,\n      node.modifiers,\n      node.name,\n      node.typeParameters,\n      node.heritageClauses,\n      updatedClassMembers\n    );\n  }\n}\n\n/**\n * Takes ConstructorParams for the given NodeArray of ParameterDeclarations\n */\nfunction getParameterTypeNamesAsArrayLiteral(\n  parameters: TS.NodeArray<TS.ParameterDeclaration>,\n  context: VisitorContext\n): TS.ArrayLiteralExpression {\n  const { factory } = context;\n  const constructorParams: TS.Expression[] = [];\n\n  for (let i = 0; i < parameters.length; i++) {\n    const parameter = parameters[i];\n    // If the parameter has no type, there's nothing to extract\n    if (parameter.type == null) {\n      constructorParams[i] = factory.createIdentifier(\"undefined\");\n    } else {\n      constructorParams[i] = factory.createNoSubstitutionTemplateLiteral(\n        pickServiceOrImplementationName(parameter.type, context)\n      );\n    }\n  }\n\n  return factory.createArrayLiteralExpression(constructorParams);\n}\n","import { TS } from \"../type/type\";\nimport { ImportedSymbol } from \"../type/imported-symbol\";\nimport { VisitorContext } from \"../transformer/visitor-context\";\nimport { RootBlock } from \"../type/root-block\";\n\ntype TSWithHelpers = typeof TS & {\n  importDefaultHelper?: TS.EmitHelper;\n  importStarHelper?: TS.EmitHelper;\n};\n\n// For some TypeScript versions, such as 3.1, these helpers are not exposed by TypeScript,\n// so they will have to be duplicated and reused from here in these rare cases\nconst HELPERS = {\n  importDefaultHelper: {\n    name: \"typescript:commonjsimportdefault\",\n    scoped: false,\n    text: '\\nvar __importDefault = (this && this.__importDefault) || function (mod) {\\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\\n};',\n  },\n  importStarHelper: {\n    name: \"typescript:commonjsimportstar\",\n    scoped: false,\n    text: '\\nvar __importStar = (this && this.__importStar) || function (mod) {\\n    if (mod && mod.__esModule) return mod;\\n    var result = {};\\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\\n    result[\"default\"] = mod;\\n    return result;\\n};',\n  },\n} as const;\n\nexport function getImportDefaultHelper(\n  typescript: TSWithHelpers\n): TS.EmitHelper {\n  return typescript.importDefaultHelper ?? HELPERS.importDefaultHelper;\n}\n\nexport function getImportStarHelper(typescript: TSWithHelpers): TS.EmitHelper {\n  return typescript.importStarHelper ?? HELPERS.importStarHelper;\n}\n\nexport function moduleKindSupportsImportHelpers(\n  moduleKind: TS.ModuleKind = TS.ModuleKind.CommonJS,\n  typescript: typeof TS\n): boolean {\n  switch (moduleKind) {\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.UMD:\n    case typescript.ModuleKind.AMD:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function moduleKindDefinesDependencies(\n  moduleKind: TS.ModuleKind = TS.ModuleKind.CommonJS,\n  typescript: typeof TS\n): boolean {\n  switch (moduleKind) {\n    case typescript.ModuleKind.UMD:\n    case typescript.ModuleKind.AMD:\n      return true;\n    default:\n      return false;\n  }\n}\n\ninterface EmitHelperFactory {\n  getUnscopedHelperName(helperName: string): TS.Identifier;\n}\n\ntype TSWithEmitHelpers = typeof TS &\n  (\n    | EmitHelperFactory\n    | {\n        createEmitHelperFactory(\n          factory: TS.TransformationContext\n        ): EmitHelperFactory;\n      }\n    | {\n        getHelperName(helperName: string): TS.Identifier;\n      }\n  );\n\nexport function getUnscopedHelperName(\n  context: VisitorContext,\n  helperName: string\n): TS.Identifier {\n  const typescript = context.typescript as TSWithEmitHelpers;\n  if (\"getUnscopedHelperName\" in typescript) {\n    return typescript.getUnscopedHelperName(helperName);\n  } else if (\"createEmitHelperFactory\" in typescript) {\n    return typescript\n      .createEmitHelperFactory(context.transformationContext)\n      .getUnscopedHelperName(helperName);\n  } else {\n    return typescript.getHelperName(helperName);\n  }\n}\n\nexport function getRootBlockInsertionPosition(\n  rootBlock: RootBlock,\n  typescript: typeof TS\n): number {\n  let insertPosition = 0;\n\n  for (let i = 0; i < rootBlock.statements.length; i++) {\n    const statement = rootBlock.statements[i];\n\n    const isUseStrict =\n      typescript.isExpressionStatement(statement) &&\n      typescript.isStringLiteralLike(statement.expression) &&\n      statement.expression.text === \"use strict\";\n\n    const isEsModuleSymbol =\n      typescript.isExpressionStatement(statement) &&\n      typescript.isCallExpression(statement.expression) &&\n      typescript.isPropertyAccessExpression(statement.expression.expression) &&\n      typescript.isIdentifier(statement.expression.expression.expression) &&\n      typescript.isIdentifier(statement.expression.expression.name) &&\n      statement.expression.expression.expression.text === \"Object\" &&\n      statement.expression.expression.name.text === \"defineProperty\" &&\n      statement.expression.arguments.length >= 2 &&\n      typescript.isIdentifier(statement.expression.arguments[0]) &&\n      statement.expression.arguments[0].text === \"exports\" &&\n      typescript.isStringLiteralLike(statement.expression.arguments[1]) &&\n      statement.expression.arguments[1].text === \"__esModule\";\n\n    if (isUseStrict || isEsModuleSymbol) {\n      insertPosition = Math.max(insertPosition, i + 1);\n    }\n  }\n  return insertPosition;\n}\n\nexport function getDefineArrayLiteralExpression(\n  sourceFile: TS.SourceFile,\n  context: VisitorContext\n): TS.ArrayLiteralExpression | undefined {\n  const { program, typescript } = context;\n  const compilerOptions = program.getCompilerOptions();\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ESNext:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ES2020:\n      // There are no such thing for these module types\n      return undefined;\n\n    // If we're targeting UMD, the root block won't be the root scope, but the Function Body of an iife\n    case typescript.ModuleKind.UMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          typescript.isParenthesizedExpression(\n            statement.expression.expression\n          ) &&\n          typescript.isFunctionExpression(\n            statement.expression.expression.expression\n          ) &&\n          statement.expression.expression.expression.parameters.length === 1\n        ) {\n          const [firstParameter] =\n            statement.expression.expression.expression.parameters;\n          if (typescript.isIdentifier(firstParameter.name)) {\n            if (firstParameter.name.text === \"factory\") {\n              for (const subStatement of statement.expression.expression\n                .expression.body.statements) {\n                if (\n                  typescript.isIfStatement(subStatement) &&\n                  subStatement.elseStatement != null &&\n                  typescript.isIfStatement(subStatement.elseStatement) &&\n                  typescript.isBlock(subStatement.elseStatement.thenStatement)\n                ) {\n                  for (const subSubStatement of subStatement.elseStatement\n                    .thenStatement.statements) {\n                    if (\n                      typescript.isExpressionStatement(subSubStatement) &&\n                      typescript.isCallExpression(subSubStatement.expression) &&\n                      subSubStatement.expression.arguments.length === 2 &&\n                      typescript.isIdentifier(\n                        subSubStatement.expression.expression\n                      ) &&\n                      subSubStatement.expression.expression.text === \"define\"\n                    ) {\n                      const [firstSubSubStatementExpressionArgument] =\n                        subSubStatement.expression.arguments;\n                      if (\n                        typescript.isArrayLiteralExpression(\n                          firstSubSubStatementExpressionArgument\n                        )\n                      ) {\n                        return firstSubSubStatementExpressionArgument;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n\n    case typescript.ModuleKind.AMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          typescript.isIdentifier(statement.expression.expression) &&\n          statement.expression.expression.text === \"define\" &&\n          statement.expression.arguments.length === 2\n        ) {\n          const [firstArgument, secondArgument] =\n            statement.expression.arguments;\n          if (typescript.isArrayLiteralExpression(firstArgument)) {\n            if (\n              typescript.isFunctionExpression(secondArgument) &&\n              secondArgument.parameters.length >= 2\n            ) {\n              const [firstParameter, secondParameter] =\n                secondArgument.parameters;\n              if (\n                typescript.isIdentifier(firstParameter.name) &&\n                typescript.isIdentifier(secondParameter.name) &&\n                firstParameter.name.text === \"require\" &&\n                secondParameter.name.text === \"exports\"\n              ) {\n                return firstArgument;\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  return undefined;\n}\n\nexport function getRootBlock(\n  sourceFile: TS.SourceFile,\n  context: VisitorContext\n): RootBlock {\n  const { program, typescript } = context;\n  const compilerOptions = program.getCompilerOptions();\n\n  switch (compilerOptions.module) {\n    // If we're targeting UMD, the root block won't be the root scope, but the Function Body of an iife\n    case typescript.ModuleKind.UMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          statement.expression.arguments.length === 1\n        ) {\n          const [firstArgument] = statement.expression.arguments;\n          if (\n            typescript.isFunctionExpression(firstArgument) &&\n            firstArgument.parameters.length === 2\n          ) {\n            const [firstParameter, secondParameter] = firstArgument.parameters;\n            if (\n              typescript.isIdentifier(firstParameter.name) &&\n              typescript.isIdentifier(secondParameter.name) &&\n              firstParameter.name.text === \"require\" &&\n              secondParameter.name.text === \"exports\"\n            ) {\n              return firstArgument.body;\n            }\n          }\n        }\n      }\n      break;\n    }\n\n    // If we're targeting AMD, the root block won't be the root scope, but the Function Body of the\n    // anonymous function provided as a second argument to the define() function\n    case typescript.ModuleKind.AMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          typescript.isIdentifier(statement.expression.expression) &&\n          statement.expression.expression.text === \"define\" &&\n          statement.expression.arguments.length === 2\n        ) {\n          const [, secondArgument] = statement.expression.arguments;\n          if (\n            typescript.isFunctionExpression(secondArgument) &&\n            secondArgument.parameters.length >= 2\n          ) {\n            const [firstParameter, secondParameter] = secondArgument.parameters;\n            if (\n              typescript.isIdentifier(firstParameter.name) &&\n              typescript.isIdentifier(secondParameter.name) &&\n              firstParameter.name.text === \"require\" &&\n              secondParameter.name.text === \"exports\"\n            ) {\n              return secondArgument.body;\n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  return sourceFile;\n}\n\nexport function isImportedSymbolImported(\n  importedSymbol: ImportedSymbol,\n  rootBlock: RootBlock,\n  context: VisitorContext\n): boolean {\n  const compilerOptions = context.program.getCompilerOptions();\n  const typescript = context.typescript;\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ES2020:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ESNext: {\n      for (const statement of rootBlock.statements) {\n        if (!typescript.isImportDeclaration(statement)) continue;\n        if (!typescript.isStringLiteralLike(statement.moduleSpecifier)) {\n          continue;\n        }\n        if (statement.moduleSpecifier.text !== importedSymbol.moduleSpecifier) {\n          continue;\n        }\n        if (statement.importClause == null) {\n          continue;\n        }\n\n        if (\"isDefaultImport\" in importedSymbol) {\n          if (importedSymbol.isDefaultImport) {\n            if (statement.importClause.name == null) {\n              continue;\n            }\n            if (statement.importClause.name.text !== importedSymbol.name) {\n              continue;\n            }\n            return true;\n          } else {\n            if (statement.importClause.namedBindings == null) continue;\n            if (\n              !typescript.isNamedImports(statement.importClause.namedBindings)\n            ) {\n              continue;\n            }\n            for (const importSpecifier of statement.importClause.namedBindings\n              .elements) {\n              if (importSpecifier.name.text !== importedSymbol.name) continue;\n              return true;\n            }\n          }\n        } else if (\"isNamespaceImport\" in importedSymbol) {\n          if (statement.importClause.namedBindings == null) continue;\n          if (\n            !typescript.isNamespaceImport(statement.importClause.namedBindings)\n          ) {\n            continue;\n          }\n          if (\n            statement.importClause.namedBindings.name.text !==\n            importedSymbol.name\n          ) {\n            continue;\n          }\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.AMD:\n    case typescript.ModuleKind.UMD: {\n      for (const statement of rootBlock.statements) {\n        if (!typescript.isVariableStatement(statement)) continue;\n        for (const declaration of statement.declarationList.declarations) {\n          if (!typescript.isIdentifier(declaration.name)) continue;\n          if (declaration.name.text !== importedSymbol.name) continue;\n          return true;\n        }\n      }\n    }\n  }\n\n  // TODO: Add support for other module systems\n  return false;\n}\n\nexport function generateImportStatementForImportedSymbolInContext(\n  importedSymbol: ImportedSymbol,\n  context: VisitorContext\n): TS.Statement | undefined {\n  const compilerOptions = context.program.getCompilerOptions();\n  const { factory, typescript } = context;\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ES2020:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ESNext: {\n      return factory.createImportDeclaration(\n        undefined,\n        undefined,\n        \"isDefaultImport\" in importedSymbol\n          ? factory.createImportClause(\n              false,\n              !importedSymbol.isDefaultImport\n                ? undefined\n                : factory.createIdentifier(importedSymbol.name),\n              importedSymbol.isDefaultImport\n                ? undefined\n                : factory.createNamedImports([\n                    factory.createImportSpecifier(\n                      false,\n                      importedSymbol.propertyName === importedSymbol.name\n                        ? undefined\n                        : factory.createIdentifier(importedSymbol.propertyName),\n                      factory.createIdentifier(importedSymbol.name)\n                    ),\n                  ])\n            )\n          : \"isNamespaceImport\" in importedSymbol\n          ? factory.createImportClause(\n              false,\n              undefined,\n              factory.createNamespaceImport(\n                factory.createIdentifier(importedSymbol.name)\n              )\n            )\n          : undefined,\n        factory.createStringLiteral(importedSymbol.moduleSpecifier)\n      );\n    }\n\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.AMD:\n    case typescript.ModuleKind.UMD: {\n      const requireCall = factory.createCallExpression(\n        factory.createIdentifier(\"require\"),\n        undefined,\n        [factory.createStringLiteral(importedSymbol.moduleSpecifier)]\n      );\n\n      let wrappedRequireCall = requireCall;\n\n      // We'll need to use a helper, '__importDefault', and wrap the require call with it\n      if (\n        compilerOptions.esModuleInterop === true &&\n        ((\"isDefaultImport\" in importedSymbol &&\n          importedSymbol.isDefaultImport) ||\n          (!(\"isDefaultImport\" in importedSymbol) &&\n            importedSymbol.isNamespaceImport))\n      ) {\n        // If tslib is being used, we can do something like 'require(\"tslib\").__import{Default|Star}(<requireCall>)'\n        if (compilerOptions.importHelpers === true) {\n          wrappedRequireCall = factory.createCallExpression(\n            factory.createPropertyAccessExpression(\n              factory.createCallExpression(\n                factory.createIdentifier(\"require\"),\n                undefined,\n                [factory.createStringLiteral(\"tslib\")]\n              ),\n              getUnscopedHelperName(\n                context,\n                \"isDefaultImport\" in importedSymbol\n                  ? \"__importDefault\"\n                  : \"__importStar\"\n              )\n            ),\n            undefined,\n            [requireCall]\n          );\n        }\n\n        // Otherwise, we'll have to make sure that the helper is being inlined in an transformation step later\n        else {\n          // We've already requested the __importDefault helper in the before transformer under these\n          // circumstances\n          wrappedRequireCall = factory.createCallExpression(\n            getUnscopedHelperName(\n              context,\n              \"isDefaultImport\" in importedSymbol\n                ? \"__importDefault\"\n                : \"__importStar\"\n            ),\n            undefined,\n            [requireCall]\n          );\n        }\n      }\n\n      return factory.createVariableStatement(\n        undefined,\n        factory.createVariableDeclarationList(\n          [\n            factory.createVariableDeclaration(\n              factory.createIdentifier(importedSymbol.name),\n              undefined,\n              undefined,\n              wrappedRequireCall\n            ),\n          ],\n          typescript.NodeFlags.Const\n        )\n      );\n    }\n  }\n\n  // TODO: Handle other module types as well\n  return undefined;\n}\n","import { DI_CONTAINER_NAME } from \"../../constant\";\nimport { TS } from \"../../../type/type\";\nimport { BeforeVisitorOptions } from \"../before-visitor-options\";\nimport { DiMethodKind } from \"../../di-method-kind\";\nimport { VisitorContext } from \"../../visitor-context\";\nimport {\n  getImportDefaultHelper,\n  getImportStarHelper,\n  moduleKindDefinesDependencies,\n  moduleKindSupportsImportHelpers,\n} from \"../../../util/ts-util\";\nimport { pickServiceOrImplementationName } from \"../util\";\n\nexport function visitCallExpression(\n  options: BeforeVisitorOptions<TS.CallExpression>\n): TS.VisitResult<TS.Node> {\n  const {\n    node,\n    childContinuation,\n    continuation,\n    context,\n    addTslibDefinition,\n    requireImportedSymbol,\n  } = options;\n  const { typescript, factory, transformationContext } = context;\n\n  const diMethod = getDiMethodKind(node.expression, context);\n\n  if (diMethod != null) {\n    switch (diMethod) {\n      case DiMethodKind.GET:\n      case DiMethodKind.HAS: {\n        // If no type arguments are given, don't modify the node at all\n        if (node.typeArguments == null || node.typeArguments[0] == null) {\n          return childContinuation(node);\n        }\n\n        return factory.updateCallExpression(\n          node,\n          node.expression,\n          node.typeArguments,\n          [\n            factory.createObjectLiteralExpression([\n              factory.createPropertyAssignment(\n                \"identifier\",\n                factory.createStringLiteral(\n                  node.typeArguments[0].getFullText().trim()\n                )\n              ),\n            ]),\n          ]\n        );\n      }\n\n      case DiMethodKind.REGISTER_SINGLETON:\n      case DiMethodKind.REGISTER_TRANSIENT: {\n        let [typeArg, implementationArg] = (node.typeArguments ??\n          []) as unknown as [\n          TS.TypeNode | undefined,\n          TS.TypeNode | TS.Expression | undefined\n        ];\n\n        // If not implementation is provided, use the type argument *as* the implementation\n        if (implementationArg == null) {\n          implementationArg = typeArg;\n        }\n\n        // If another implementation is passed, used that one instead\n        if (node.arguments.length > 0) {\n          implementationArg = node.arguments[0];\n        }\n\n        if (typeArg == null || implementationArg == null) {\n          return childContinuation(node);\n        }\n\n        const typeArgText = pickServiceOrImplementationName(typeArg, context);\n        const implementationArgText = pickServiceOrImplementationName(\n          implementationArg,\n          context\n        );\n\n        // If the Implementation is a TypeNode, and if it originates from an ImportDeclaration, it may be stripped from the file since Typescript won't Type-check the updates from\n        // a CustomTransformer and such a node would normally be removed from the imports.\n        // to fix it, add an ImportDeclaration if needed\n        if (typescript.isTypeNode(implementationArg)) {\n          const matchingImport = findMatchingImportDeclarationForIdentifier(\n            implementationArgText,\n            options\n          );\n          if (\n            matchingImport != null &&\n            typescript.isStringLiteralLike(\n              matchingImport.importDeclaration.moduleSpecifier\n            )\n          ) {\n            switch (matchingImport.kind) {\n              case \"default\": {\n                const compilerOptions = context.program.getCompilerOptions();\n\n                // Log a request for the __importDefault helper already if we will\n                // need it in a later transformation step\n                if (\n                  moduleKindSupportsImportHelpers(\n                    compilerOptions.module,\n                    typescript\n                  ) &&\n                  compilerOptions.esModuleInterop === true &&\n                  compilerOptions.importHelpers !== true\n                ) {\n                  transformationContext.requestEmitHelper(\n                    getImportDefaultHelper(typescript)\n                  );\n                }\n\n                // Log a request for adding 'tslib' to the define([...]) array for the current\n                // module system if it relies on declaring dependencies (such as UMD, AMD, and SystemJS does)\n                if (\n                  moduleKindDefinesDependencies(\n                    compilerOptions.module,\n                    typescript\n                  ) &&\n                  compilerOptions.esModuleInterop === true &&\n                  compilerOptions.importHelpers === true\n                ) {\n                  addTslibDefinition();\n                }\n\n                requireImportedSymbol({\n                  isDefaultImport: true,\n                  moduleSpecifier:\n                    matchingImport.importDeclaration.moduleSpecifier.text,\n                  name: matchingImport.identifier.text,\n                  propertyName: matchingImport.identifier.text,\n                });\n                break;\n              }\n\n              case \"namedImport\": {\n                requireImportedSymbol({\n                  isDefaultImport: false,\n                  moduleSpecifier:\n                    matchingImport.importDeclaration.moduleSpecifier.text,\n                  name: matchingImport.importSpecifier.name.text,\n                  propertyName:\n                    matchingImport.importSpecifier.propertyName?.text ??\n                    matchingImport.importSpecifier.name.text,\n                });\n                break;\n              }\n\n              case \"namespace\": {\n                const compilerOptions = context.program.getCompilerOptions();\n\n                // Log a request for the __importStar helper already if you will\n                // need it in a later transformation step\n                if (\n                  moduleKindSupportsImportHelpers(\n                    compilerOptions.module,\n                    typescript\n                  ) &&\n                  compilerOptions.esModuleInterop === true &&\n                  compilerOptions.importHelpers !== true\n                ) {\n                  transformationContext.requestEmitHelper(\n                    getImportStarHelper(typescript)\n                  );\n                }\n\n                requireImportedSymbol({\n                  isNamespaceImport: true,\n                  moduleSpecifier:\n                    matchingImport.importDeclaration.moduleSpecifier.text,\n                  name: matchingImport.identifier.text,\n                });\n                break;\n              }\n            }\n          }\n        }\n\n        return factory.updateCallExpression(\n          node,\n          node.expression,\n          node.typeArguments,\n          [\n            typescript.isTypeNode(implementationArg)\n              ? factory.createIdentifier(\"undefined\")\n              : (continuation(implementationArg) as TS.Expression),\n            factory.createObjectLiteralExpression([\n              factory.createPropertyAssignment(\n                \"identifier\",\n                factory.createNoSubstitutionTemplateLiteral(typeArgText)\n              ),\n              ...(!typescript.isTypeNode(implementationArg)\n                ? []\n                : [\n                    factory.createPropertyAssignment(\n                      \"implementation\",\n                      factory.createIdentifier(\n                        rewriteImplementationName(\n                          implementationArgText,\n                          options\n                        )\n                      )\n                    ),\n                  ]),\n            ]),\n          ]\n        );\n      }\n    }\n  }\n\n  return childContinuation(node);\n}\n\ninterface FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"default\" | \"namespace\" | \"namedImport\";\n  importDeclaration: TS.ImportDeclaration;\n}\n\ninterface FindMatchingImportDeclarationForIdentifierNamedImportResult\n  extends FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"namedImport\";\n  importSpecifier: TS.ImportSpecifier;\n}\n\ninterface FindMatchingImportDeclarationForIdentifierDefaultResult\n  extends FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"default\";\n  identifier: TS.Identifier;\n}\n\ninterface FindMatchingImportDeclarationForIdentifierNamespaceResult\n  extends FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"namespace\";\n  identifier: TS.Identifier;\n}\n\ntype FindMatchingImportDeclarationForIdentifierResult =\n  | FindMatchingImportDeclarationForIdentifierNamedImportResult\n  | FindMatchingImportDeclarationForIdentifierDefaultResult\n  | FindMatchingImportDeclarationForIdentifierNamespaceResult;\n\nfunction findMatchingImportDeclarationForIdentifier(\n  identifier: string,\n  options: BeforeVisitorOptions<TS.CallExpression>\n): FindMatchingImportDeclarationForIdentifierResult | undefined {\n  const {\n    sourceFile,\n    context: { typescript },\n  } = options;\n\n  // Find the matching import\n  const importDeclarations = sourceFile.statements.filter(\n    typescript.isImportDeclaration\n  );\n\n  for (const importDeclaration of importDeclarations) {\n    if (importDeclaration.importClause == null) continue;\n\n    // Default import\n    if (importDeclaration.importClause.name?.text === identifier) {\n      return {\n        importDeclaration,\n        kind: \"default\",\n        identifier: importDeclaration.importClause.name,\n      };\n    } else if (importDeclaration.importClause.namedBindings != null) {\n      if (\n        typescript.isNamespaceImport(\n          importDeclaration.importClause.namedBindings\n        )\n      ) {\n        if (\n          importDeclaration.importClause.namedBindings.name.text === identifier\n        ) {\n          return {\n            importDeclaration,\n            kind: \"namespace\",\n            identifier: importDeclaration.importClause.namedBindings.name,\n          };\n        }\n      } else {\n        for (const importSpecifier of importDeclaration.importClause\n          .namedBindings.elements) {\n          if (importSpecifier.name.text === identifier) {\n            return {\n              importDeclaration,\n              kind: \"namedImport\",\n              importSpecifier: importSpecifier,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // No import was matched\n  return undefined;\n}\n\nfunction rewriteImplementationName(\n  name: string,\n  options: BeforeVisitorOptions<TS.CallExpression>\n): string {\n  const {\n    context: { typescript },\n  } = options;\n  const compilerOptions = options.context.program.getCompilerOptions();\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ES2020:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ESNext:\n      return name;\n\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.AMD:\n    case typescript.ModuleKind.UMD: {\n      // Find the matching import\n      const match = findMatchingImportDeclarationForIdentifier(name, options);\n      if (match == null) {\n        return name;\n      }\n\n      switch (match.kind) {\n        case \"default\":\n          return `${name}.default`;\n        case \"namespace\":\n          return name;\n        case \"namedImport\":\n          return `${name}.${\n            (match.importSpecifier.propertyName ?? match.importSpecifier.name)\n              .text\n          }`;\n      }\n\n      // Fall back to returning the original name\n      return name;\n    }\n\n    default:\n      // TODO: Add support for SystemJS here\n      return name;\n  }\n}\n\nfunction getDiMethodKind(\n  node: TS.Expression,\n  context: VisitorContext\n): DiMethodKind | undefined {\n  if (\n    !context.typescript.isPropertyAccessExpression(node) &&\n    !context.typescript.isElementAccessExpression(node)\n  ) {\n    return undefined;\n  }\n\n  // Don't proceed unless the left-hand expression is the DIServiceContainer\n  const type = context.typeChecker.getTypeAtLocation(node.expression);\n\n  if (\n    type == null ||\n    type.symbol == null ||\n    type.symbol.escapedName !== DI_CONTAINER_NAME\n  ) {\n    return undefined;\n  }\n\n  let name: string;\n\n  // If it is an element access expression, evaluate the argument expression\n  if (context.typescript.isElementAccessExpression(node)) {\n    const evaluationResult = context.evaluate(node.argumentExpression);\n\n    // If no value could be computed, or if the value isn't of type string, do nothing\n    if (\n      !evaluationResult.success ||\n      typeof evaluationResult.value !== \"string\"\n    ) {\n      return undefined;\n    } else {\n      name = evaluationResult.value;\n    }\n  } else {\n    name = node.name.text;\n  }\n\n  switch (name) {\n    case DiMethodKind.GET:\n    case DiMethodKind.HAS:\n    case DiMethodKind.REGISTER_SINGLETON:\n    case DiMethodKind.REGISTER_TRANSIENT:\n      return name;\n    default:\n      return undefined;\n  }\n}\n","import { BeforeVisitorOptions } from \"../before-visitor-options\";\nimport { TS } from \"../../../type/type\";\nimport { visitClassLikeDeclaration } from \"./visit-class-like-declaration\";\nimport { visitCallExpression } from \"./visit-call-expression\";\n\nexport function visitNode<T extends TS.Node>(\n  options: BeforeVisitorOptions<T>\n): TS.VisitResult<TS.Node> {\n  if (options.context.typescript.isClassLike(options.node)) {\n    return visitClassLikeDeclaration({ ...options, node: options.node });\n  } else if (options.context.typescript.isCallExpression(options.node)) {\n    return visitCallExpression({ ...options, node: options.node });\n  }\n\n  return options.childContinuation(options.node);\n}\n","import { BaseVisitorContext, VisitorContext } from \"../visitor-context\";\nimport { TS } from \"../../type/type\";\nimport { BeforeVisitorOptions } from \"./before-visitor-options\";\nimport { visitNode } from \"./visitor/visit-node\";\nimport { ImportedSymbol } from \"../../type/imported-symbol\";\nimport { ensureNodeFactory } from \"compatfactory\";\n\nexport function beforeTransformer(\n  context: BaseVisitorContext\n): TS.TransformerFactory<TS.SourceFile> {\n  return (transformationContext) => {\n    const factory = ensureNodeFactory(\n      transformationContext.factory ?? context.typescript\n    );\n\n    return (sourceFile) =>\n      transformSourceFile(sourceFile, {\n        ...context,\n        transformationContext,\n        factory,\n      });\n  };\n}\n\nfunction transformSourceFile(\n  sourceFile: TS.SourceFile,\n  context: VisitorContext\n): TS.SourceFile {\n  const requiredImportedSymbolSet = new Set<ImportedSymbol>();\n\n  /**\n   * An optimization in which every imported symbol is converted into\n   * a string that can be matched against directly to guard against\n   * duplicates\n   */\n  const requiredImportedSymbolSetFlags = new Set<string>();\n\n  context.sourceFileToAddTslibDefinition.set(sourceFile.fileName, false);\n  context.sourceFileToRequiredImportedSymbolSet.set(\n    sourceFile.fileName,\n    requiredImportedSymbolSet\n  );\n\n  const computeImportedSymbolFlag = (symbol: ImportedSymbol): string =>\n    [\n      \"name\",\n      \"propertyName\",\n      \"moduleSpecifier\",\n      \"isNamespaceImport\",\n      \"isDefaultImport\",\n    ]\n      .map(\n        (property) =>\n          `${property}:${symbol[property as keyof ImportedSymbol] ?? false}`\n      )\n      .join(\"|\");\n\n  const visitorOptions: Omit<\n    BeforeVisitorOptions<TS.Node>,\n    \"node\" | \"sourceFile\"\n  > = {\n    context,\n\n    addTslibDefinition: (): void => {\n      context.sourceFileToAddTslibDefinition.set(sourceFile.fileName, true);\n    },\n\n    requireImportedSymbol: (importedSymbol: ImportedSymbol): void => {\n      // Guard against duplicates and compute a string so we can do\n      // constant time lookups to compare against existing symbols\n      const flag = computeImportedSymbolFlag(importedSymbol);\n      if (requiredImportedSymbolSetFlags.has(flag)) return;\n      requiredImportedSymbolSetFlags.add(flag);\n\n      requiredImportedSymbolSet.add(importedSymbol);\n    },\n\n    continuation: (node) =>\n      visitNode({\n        ...visitorOptions,\n        sourceFile,\n        node,\n      }),\n    childContinuation: (node) =>\n      context.typescript.visitEachChild(\n        node,\n        (cbNode) =>\n          visitNode({\n            ...visitorOptions,\n            sourceFile,\n            node: cbNode,\n          }),\n        context.transformationContext\n      ),\n  };\n\n  return visitorOptions.continuation(sourceFile) as TS.SourceFile;\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport {\n  generateImportStatementForImportedSymbolInContext,\n  getRootBlockInsertionPosition,\n  isImportedSymbolImported,\n} from \"../../../util/ts-util\";\nimport { RootBlock } from \"../../../type/root-block\";\n\nexport function visitRootBlock(\n  options: AfterVisitorOptions<RootBlock>\n): TS.Statement[] {\n  const { node, sourceFile, context } = options;\n  const { typescript } = context;\n\n  const leadingExtraStatements: TS.Statement[] = [];\n\n  for (const importedSymbol of context.sourceFileToRequiredImportedSymbolSet.get(\n    sourceFile.fileName\n  ) ?? new Set()) {\n    if (isImportedSymbolImported(importedSymbol, node, context)) continue;\n\n    const missingImportStatement = generateImportStatementForImportedSymbolInContext(\n      importedSymbol,\n      context\n    );\n\n    if (missingImportStatement != null) {\n      leadingExtraStatements.push(missingImportStatement);\n    }\n  }\n\n  const insertPosition = getRootBlockInsertionPosition(node, typescript);\n\n  return [\n    ...node.statements.slice(0, insertPosition),\n    ...leadingExtraStatements,\n    ...node.statements.slice(insertPosition),\n  ];\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport { visitRootBlock } from \"./visit-root-block\";\n\nexport function visitRootBlockSourceFile(\n  options: AfterVisitorOptions<TS.SourceFile>\n): TS.VisitResult<TS.Node> {\n  const { node, context } = options;\n  const { factory } = context;\n\n  return factory.updateSourceFile(\n    node,\n    visitRootBlock(options),\n    node.isDeclarationFile,\n    node.referencedFiles,\n    node.typeReferenceDirectives,\n    node.hasNoDefaultLib,\n    node.libReferenceDirectives\n  );\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport { visitRootBlock } from \"./visit-root-block\";\n\nexport function visitRootBlockBlock(\n  options: AfterVisitorOptions<TS.Block>\n): TS.VisitResult<TS.Node> {\n  const { node, context } = options;\n  const { factory } = context;\n\n  return factory.updateBlock(node, visitRootBlock(options));\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\n\nexport function visitDefineArrayLiteralExpression(\n  options: AfterVisitorOptions<TS.ArrayLiteralExpression>\n): TS.ArrayLiteralExpression {\n  const { node, sourceFile, context } = options;\n  const { typescript, factory } = context;\n\n  const trailingExtraExpressions: TS.Expression[] = [];\n\n  for (const importedSymbol of context.sourceFileToRequiredImportedSymbolSet.get(\n    sourceFile.fileName\n  ) ?? new Set()) {\n    // Skip the node if it is already declared as a dependency\n    if (\n      node.elements.some(\n        (element) =>\n          typescript.isStringLiteralLike(element) &&\n          element.text === importedSymbol.moduleSpecifier\n      )\n    ) {\n      continue;\n    }\n\n    trailingExtraExpressions.push(\n      factory.createStringLiteral(importedSymbol.moduleSpecifier)\n    );\n  }\n\n  if (\n    context.sourceFileToAddTslibDefinition.get(sourceFile.fileName) === true\n  ) {\n    trailingExtraExpressions.push(factory.createStringLiteral(\"tslib\"));\n  }\n\n  if (trailingExtraExpressions.length < 1) {\n    return node;\n  }\n\n  return factory.updateArrayLiteralExpression(node, [\n    ...node.elements,\n    ...trailingExtraExpressions,\n  ]);\n}\n","import { TS } from \"../../../type/type\";\nimport { visitRootBlockSourceFile } from \"./visit-root-block-source-file\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport { visitRootBlockBlock } from \"./visit-root-block-block\";\nimport { visitDefineArrayLiteralExpression } from \"./visit-define-array-literal-expression\";\n\nexport function visitNode<T extends TS.Node>(\n  options: AfterVisitorOptions<T>\n): TS.VisitResult<TS.Node> {\n  const {\n    node,\n    childContinuation,\n    defineArrayLiteralExpression,\n    rootBlock,\n    context: { typescript },\n  } = options;\n  if (typescript.isSourceFile(node) && rootBlock === node) {\n    return visitRootBlockSourceFile({ ...options, node });\n  } else if (typescript.isBlock(node) && rootBlock === node) {\n    return visitRootBlockBlock({ ...options, node });\n  } else if (\n    typescript.isArrayLiteralExpression(node) &&\n    defineArrayLiteralExpression === node\n  ) {\n    return visitDefineArrayLiteralExpression({\n      ...options,\n      node,\n    });\n  }\n\n  return childContinuation(options.node);\n}\n","import { BaseVisitorContext, VisitorContext } from \"../visitor-context\";\nimport { TS } from \"../../type/type\";\nimport { AfterVisitorOptions } from \"./after-visitor-options\";\nimport { visitNode } from \"./visitor/visit-node\";\nimport {\n  getDefineArrayLiteralExpression,\n  getRootBlock,\n} from \"../../util/ts-util\";\nimport { ensureNodeFactory } from \"compatfactory\";\n\ntype SourceFileWithEmitNodes = TS.SourceFile & {\n  emitNode?: {\n    helpers?: TS.EmitHelper[];\n  };\n};\n\nexport function afterTransformer(\n  context: BaseVisitorContext\n): TS.TransformerFactory<TS.SourceFile> {\n  return (transformationContext) => {\n    const factory = ensureNodeFactory(\n      transformationContext.factory ?? context.typescript\n    );\n\n    return (sourceFile) =>\n      transformSourceFile(sourceFile, {\n        ...context,\n        transformationContext,\n        factory,\n      });\n  };\n}\n\nfunction transformSourceFile(\n  sourceFile: SourceFileWithEmitNodes,\n  context: VisitorContext\n): TS.SourceFile {\n  // For TypeScript versions below 3.5, there may be instances\n  // where EmitHelpers such as __importDefault or __importStar is duplicated.\n  // For these TypeScript versions, well have to guard against this behavior\n  if (sourceFile.emitNode != null && sourceFile.emitNode.helpers != null) {\n    const seenNames = new Set();\n    const filtered = sourceFile.emitNode.helpers.filter((helper) => {\n      if (seenNames.has(helper.name)) return false;\n      seenNames.add(helper.name);\n      return true;\n    });\n\n    // Reassign the emitNodes if they changed\n    if (filtered.length !== sourceFile.emitNode.helpers.length) {\n      sourceFile.emitNode.helpers = filtered;\n    }\n  }\n\n  const visitorOptions: Omit<\n    AfterVisitorOptions<TS.Node>,\n    \"node\" | \"sourceFile\"\n  > = {\n    context,\n    defineArrayLiteralExpression: getDefineArrayLiteralExpression(\n      sourceFile,\n      context\n    ),\n    rootBlock: getRootBlock(sourceFile, context),\n\n    continuation: (node) =>\n      visitNode({\n        ...visitorOptions,\n        sourceFile,\n        node,\n      }),\n    childContinuation: (node) =>\n      context.typescript.visitEachChild(\n        node,\n        (cbNode) =>\n          visitNode({\n            ...visitorOptions,\n            sourceFile,\n            node: cbNode,\n          }),\n        context.transformationContext\n      ),\n  };\n\n  return visitorOptions.continuation(sourceFile) as TS.SourceFile;\n}\n","import { TS } from \"../type/type\";\nimport { DiOptions } from \"./di-options\";\nimport { BaseVisitorContext } from \"./visitor-context\";\nimport { evaluate } from \"ts-evaluator\";\nimport * as TSModule from \"typescript\";\nimport { beforeTransformer } from \"./before/before-transformer\";\nimport { afterTransformer } from \"./after/after-transformer\";\n\n/**\n * CustomTransformer that associates constructor arguments with any given class declaration\n */\nexport function di({\n  typescript = TSModule,\n  ...rest\n}: DiOptions): TS.CustomTransformers {\n  const typeChecker = rest.program.getTypeChecker();\n\n  // Prepare a VisitorContext\n  const visitorContext: BaseVisitorContext = {\n    ...rest,\n    typescript,\n    typeChecker,\n    sourceFileToAddTslibDefinition: new Map(),\n    sourceFileToRequiredImportedSymbolSet: new Map(),\n    evaluate: (node) =>\n      evaluate({\n        node,\n        typeChecker,\n        typescript,\n      }),\n  };\n\n  return {\n    before: [beforeTransformer(visitorContext)],\n    after: [afterTransformer(visitorContext)],\n  };\n}\n"],"names":["visitNode","transformSourceFile","TSModule"],"mappings":"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"}