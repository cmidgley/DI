{"version":3,"file":"index.js","sources":["../../src/constructor-arguments/constructor-arguments-identifier.ts","../../src/di-container/di-container.ts"],"sourcesContent":["export const CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER = `___CTOR_ARGS___`;\nexport const CONSTRUCTOR_ARGUMENTS_SYMBOL: unique symbol = Symbol.for(\n  CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER\n);\n","import { IConstructInstanceOptions } from \"../construct-instance-options/i-construct-instance-options\";\nimport { IParent } from \"../construct-instance-options/i-parent\";\nimport { ConstructorArgument } from \"../constructor-arguments/constructor-argument\";\nimport { CONSTRUCTOR_ARGUMENTS_SYMBOL } from \"../constructor-arguments/constructor-arguments-identifier\";\nimport { IGetOptions } from \"../get-options/i-get-options\";\nimport { IHasOptions } from \"../has-options/i-has-options\";\nimport { NewableService } from \"../newable-service/newable-service\";\nimport {\n\tIRegisterOptionsWithImplementation,\n\tIRegisterOptionsWithoutImplementation,\n\tRegisterOptions,\n} from \"../register-options/i-register-options\";\nimport { RegistrationKind } from \"../registration-kind/registration-kind\";\nimport { IDIContainer } from \"./i-di-container\";\nimport { RegistrationRecord } from \"../registration-record/i-registration-record\";\nimport { ImplementationInstance } from \"../implementation/implementation\";\n\n/**\n * A Dependency-Injection container that holds services and can produce instances of them as required.\n * It mimics reflection by parsing the app at compile-time and supporting the generic-reflection syntax.\n * @author Frederik Wessberg\n */\nexport class DIContainer implements IDIContainer {\n\t/**\n\t * Singleton instance of the container, for global sharing of the container.\n\t */\n\tstatic diContainer?: DIContainer;\n\n\t/**\n\t * A map between interface names and the services that should be dependency injected\n\t */\n\tprivate readonly constructorArguments: Map<string, ConstructorArgument[]> = new Map();\n\t/**\n\t * A Map between identifying names for services and their IRegistrationRecords.\n\t */\n\tprivate readonly serviceRegistry: Map<string, RegistrationRecord<unknown>> = new Map();\n\n\t/**\n\t * A map between identifying names for services and concrete instances of their implementation.\n\t */\n\tprivate readonly instances: Map<string, unknown> = new Map();\n\n\t/**\n\t * Registers a service that will be instantiated once in the application lifecycle. All requests\n\t * for the service will retrieve the same instance of it.\n\t *\n\t * You should not pass any options to the method if using the compiler. It will do that automatically.\n\t */\n\tregisterSingleton<T, U extends T = T>(\n\t\tnewExpression: ImplementationInstance<U>,\n\t\toptions: IRegisterOptionsWithoutImplementation\n\t): void;\n\tregisterSingleton<T, U extends T = T>(\n\t\tnewExpression: undefined,\n\t\toptions: IRegisterOptionsWithImplementation<U>\n\t): void;\n\tregisterSingleton<T, U extends T = T>(\n\t\tnewExpression?: ImplementationInstance<U> | undefined,\n\t\toptions?: RegisterOptions<U>\n\t): void;\n\tregisterSingleton<T, U extends T = T>(\n\t\tnewExpression?: ImplementationInstance<U> | undefined,\n\t\toptions?: RegisterOptions<U>\n\t): void {\n\t\tif (options == null) {\n\t\t\tthrow new ReferenceError(`2 arguments required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`);\n\t\t}\n\t\tif (newExpression == null) {\n\t\t\treturn this.register(\"SINGLETON\", newExpression, <IRegisterOptionsWithImplementation<U>>options);\n\t\t} else {\n\t\t\treturn this.register(\"SINGLETON\", newExpression, options);\n\t\t}\n\t}\n\n\t/**\n\t * Registers a service that will be instantiated every time it is requested throughout the application lifecycle.\n\t * This means that every call to get() will return a unique instance of the service.\n\t *\n\t * You should not pass any options to the method if using the compiler. It will do that automatically.\n\t */\n\tregisterTransient<T, U extends T = T>(\n\t\tnewExpression: ImplementationInstance<U>,\n\t\toptions: IRegisterOptionsWithoutImplementation\n\t): void;\n\tregisterTransient<T, U extends T = T>(\n\t\tnewExpression: undefined,\n\t\toptions: IRegisterOptionsWithImplementation<U>\n\t): void;\n\tregisterTransient<T, U extends T = T>(\n\t\tnewExpression?: ImplementationInstance<U> | undefined,\n\t\toptions?: RegisterOptions<U>\n\t): void;\n\tregisterTransient<T, U extends T = T>(\n\t\tnewExpression?: ImplementationInstance<U> | undefined,\n\t\toptions?: RegisterOptions<U>\n\t): void {\n\t\tif (options == null) {\n\t\t\tthrow new ReferenceError(`2 arguments required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`);\n\t\t}\n\t\tif (newExpression == null) {\n\t\t\treturn this.register(\"TRANSIENT\", newExpression, <IRegisterOptionsWithImplementation<U>>options);\n\t\t} else {\n\t\t\treturn this.register(\"TRANSIENT\", newExpression, options);\n\t\t}\n\t}\n\n\t/**\n\t * Gets an instance of the service matching the interface given as a generic type parameter.\n\t * For example, 'container.get<IFoo>()' returns a concrete instance of the implementation associated with the\n\t * generic interface name.\n\t *\n\t * You should not pass any options to the method if using the compiler. It will do that automatically.\n\t */\n\tget<T>(options?: IGetOptions): T {\n\t\tif (options == null) {\n\t\t\tthrow new ReferenceError(`1 argument required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`);\n\t\t}\n\t\treturn this.constructInstance<T>(options);\n\t}\n\n\t/**\n\t * Returns true if a service has been registered matching the interface given as a generic type parameter.\n\t * For example, 'container.get<IFoo>()' returns a concrete instance of the implementation associated with the\n\t * generic interface name.\n\t *\n\t * You should not pass any options to the method if using the compiler. It will do that automatically.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\thas<T>(options?: IHasOptions): boolean {\n\t\tif (options == null) {\n\t\t\tthrow new ReferenceError(`1 argument required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`);\n\t\t}\n\t\treturn this.serviceRegistry.has(options.identifier);\n\t}\n\n  \n\t/**\n\t * Provides a global shared instance of a container (singleton).  This is\n\t * especially useful when creating libraries (such as in a monorepo) where\n\t * the library's imported file defines the dependencies that need to be\n\t * injected for the library to operate without exposing the full set of\n\t * injections necessary for each library.\n\t *\n\t * @returns Singleton container\n\t */\n\tpublic static container(): DIContainer {\n\t\tif (!DIContainer.diContainer)\n\t\t\tDIContainer.diContainer = new DIContainer();\n\t\treturn DIContainer.diContainer;\n\t}\n  \n\t/**\n\t * Registers a service\n\t */\n\tprivate register<T, U extends T = T>(\n\t\tkind: RegistrationKind,\n\t\tnewExpression: ImplementationInstance<U>,\n\t\toptions: IRegisterOptionsWithoutImplementation\n\t): void;\n\tprivate register<T, U extends T = T>(\n\t\tkind: RegistrationKind,\n\t\tnewExpression: undefined,\n\t\toptions: IRegisterOptionsWithImplementation<U>\n\t): void;\n\tprivate register<T, U extends T = T>(\n\t\tkind: RegistrationKind,\n\t\tnewExpression: ImplementationInstance<U> | undefined,\n\t\toptions: RegisterOptions<U>\n\t): void {\n\t\t// Take all of the constructor arguments for the implementation\n\t\tconst implementationArguments =\n\t\t\t\"implementation\" in options &&\n\t\t\toptions.implementation != null &&\n\t\t\toptions.implementation[CONSTRUCTOR_ARGUMENTS_SYMBOL] != null\n\t\t\t\t? options.implementation[CONSTRUCTOR_ARGUMENTS_SYMBOL]!\n\t\t\t\t: [];\n\t\tthis.constructorArguments.set(options.identifier, implementationArguments);\n\n\t\tthis.serviceRegistry.set(\n\t\t\toptions.identifier,\n\t\t\t\"implementation\" in options && options.implementation != null\n\t\t\t\t? { ...options, kind }\n\t\t\t\t: { ...options, kind, newExpression: newExpression! }\n\t\t);\n\t}\n\n\t/**\n\t * Returns true if an instance exists that matches the given identifier.\n\t */\n\tprivate hasInstance(identifier: string): boolean {\n\t\treturn this.getInstance(identifier) != null;\n\t}\n\n\t/**\n\t * Gets the cached instance, if any, associated with the given identifier.\n\t */\n\tprivate getInstance<T>(identifier: string): T | null {\n\t\tconst instance = this.instances.get(identifier);\n\t\treturn instance == null ? null : <T>instance;\n\t}\n\n\t/**\n\t * Gets an IRegistrationRecord associated with the given identifier.\n\t */\n\tprivate getRegistrationRecord<T>({ identifier, parentChain }: IConstructInstanceOptions): RegistrationRecord<T> {\n\t\tconst record = this.serviceRegistry.get(identifier);\n\t\tif (record == null) {\n\t\t\tthrow new ReferenceError(\n\t\t\t\t`${this.constructor.name} could not find a service for identifier: \"${identifier}\". ${\n\t\t\t\t\tparentChain == null || parentChain.length < 1\n\t\t\t\t\t\t? \"\"\n\t\t\t\t\t\t: `It is required by the service: '${parentChain\n\t\t\t\t\t\t\t\t.map((parent) => parent.identifier)\n\t\t\t\t\t\t\t\t.join(\" -> \")}'.`\n\t\t\t\t} Remember to register it as a service!`\n\t\t\t);\n\t\t}\n\t\treturn <RegistrationRecord<T>>record;\n\t}\n\n\t/**\n\t * Caches the given instance so that it can be retrieved in the future.\n\t */\n\tprivate setInstance<T>(identifier: string, instance: T): T {\n\t\tthis.instances.set(identifier, instance);\n\t\treturn instance;\n\t}\n\n\t/**\n\t * Gets a lazy reference to another service\n\t */\n\tprivate getLazyIdentifier<T>(lazyPointer: () => T): T {\n\t\treturn <T>new Proxy({}, { get: (_, key: keyof T & string) => lazyPointer()[key] });\n\t}\n\n\t/**\n\t * Constructs a new instance of the given identifier and returns it.\n\t * It checks the constructor arguments and injects any services it might depend on recursively.\n\t */\n\tprivate constructInstance<T>({ identifier, parentChain = [] }: IConstructInstanceOptions): T {\n\t\tconst registrationRecord = this.getRegistrationRecord({\n\t\t\tidentifier,\n\t\t\tparentChain,\n\t\t});\n\n\t\t// If an instance already exists (and it is a singleton), return that one\n\t\tif (this.hasInstance(identifier) && registrationRecord.kind === \"SINGLETON\") {\n\t\t\treturn <T>this.getInstance(identifier);\n\t\t}\n\n\t\t// Otherwise, instantiate a new one\n\t\tlet instance: T;\n\n\t\tconst me: IParent<T> = {\n\t\t\tidentifier,\n\t\t\tref: this.getLazyIdentifier(() => instance),\n\t\t};\n\n\t\t// If a user-provided new-expression has been provided, invoke that to get an instance.\n\t\tif (\"newExpression\" in registrationRecord) {\n\t\t\tif (typeof registrationRecord.newExpression !== \"function\") {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Could not instantiate the service with the identifier: '${registrationRecord.identifier}': You provided a custom instantiation argument, but it wasn't of type function. It has to be a function that returns whatever should be used as an instance of the Service!`\n\t\t\t\t);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinstance = registrationRecord.newExpression() as T;\n\t\t\t} catch (ex) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Could not instantiate the service with the identifier: '${registrationRecord.identifier}': When you registered the service, you provided a custom instantiation function, but it threw an exception when it was run!`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t// Find the arguments for the identifier\n\t\t\tconst mappedArgs = this.constructorArguments.get(identifier);\n\t\t\tif (mappedArgs == null) {\n\t\t\t\tthrow new ReferenceError(\n\t\t\t\t\t`${this.constructor.name} could not find constructor arguments for the service: '${identifier}'. Have you registered it as a service?`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Instantiate all of the argument services (or re-use them if they were registered as singletons)\n\t\t\tconst instanceArgs = mappedArgs.map((dep) => {\n\t\t\t\tif (dep === undefined) return undefined;\n\t\t\t\tconst matchedParent = parentChain.find((parent) => parent.identifier === dep);\n\t\t\t\tif (matchedParent != null) return matchedParent.ref;\n\t\t\t\treturn this.constructInstance<T>({\n\t\t\t\t\tidentifier: dep,\n\t\t\t\t\tparentChain: [...parentChain, me],\n\t\t\t\t});\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\t// Try to construct an instance with 'new' and if it fails, call the implementation directly.\n\t\t\t\tconst newable = registrationRecord.implementation as NewableService<T>;\n\t\t\t\tinstance = new newable(...instanceArgs);\n\t\t\t} catch (ex) {\n\t\t\t\tif (registrationRecord.implementation == null) {\n\t\t\t\t\tthrow new ReferenceError(\n\t\t\t\t\t\t`${this.constructor.name} could not construct a new service of kind: ${identifier}. Reason: No implementation was given!`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst constructable = registrationRecord.implementation;\n\t\t\t\t// Try without 'new' and call the implementation as a function.\n\t\t\t\ttry {\n\t\t\t\t\tinstance = (constructable as unknown as CallableFunction)(...instanceArgs);\n\t\t\t\t} catch {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn registrationRecord.kind === \"SINGLETON\" ? this.setInstance<T>(identifier, instance) : instance;\n\t}\n}\n\nconst DI_COMPILER_ERROR_HINT = `Note: You must use DI-Compiler (https://github.com/wessberg/di-compiler) for this library to work correctly. Please consult the readme for instructions on how to install and configure it for your project.`;\n"],"names":[],"mappings":"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"}